import type { PuzzleOutput } from './puzzle-master';

/**
 * Puzzle structure (generated by Puzzle Master)
 */
export interface Puzzle {
  phrase: string;
  category: string;
}

/**
 * Game state for word guessing
 */
export interface GameState {
  puzzle: Puzzle;
  guessedLetters: Set<string>;
  solved: boolean;
  failed: boolean;
}

// In-memory game state
let currentGameState: GameState | undefined;

/**
 * Check if we need a new puzzle (no game or game is over)
 * @returns True if a new puzzle is needed
 */
export function needsNewPuzzle(): boolean {
  return (
    currentGameState === undefined ||
    currentGameState.solved ||
    currentGameState.failed
  );
}

/**
 * Start a new game with a puzzle from the Puzzle Master
 * @param puzzleOutput - The puzzle generated by the Puzzle Master
 * @returns The initial game state
 */
export function startNewGame(puzzleOutput: PuzzleOutput): GameState {
  currentGameState = {
    puzzle: {
      phrase: puzzleOutput.phrase.toUpperCase(),
      category: puzzleOutput.category,
    },
    guessedLetters: new Set(),
    solved: false,
    failed: false,
  };
  return currentGameState;
}

/**
 * Get the current game state (may be undefined)
 * @returns The current game state or undefined if no game exists
 */
export function getGameState(): GameState | undefined {
  return currentGameState;
}

/**
 * Reset game state (for testing)
 */
export function resetGameState(): void {
  currentGameState = undefined;
}

/**
 * Update game state after processing a move
 * @param newState - The new game state to set
 */
export function updateGameState(newState: GameState): void {
  currentGameState = newState;
}

/**
 * Get the current board display (revealed letters, underscores for hidden)
 * @param state - The game state
 * @returns The board display string
 */
export function getCurrentBoard(state: GameState): string {
  // eslint-disable-next-line @typescript-eslint/no-misused-spread -- Puzzles are ASCII-only A-Z letters, no Unicode concerns
  return [...state.puzzle.phrase]
    .map((char) => {
      if (char === ' ') {
        return ' ';
      }
      if (state.guessedLetters.has(char.toUpperCase())) {
        return char;
      }
      return '_';
    })
    .join('');
}

/**
 * Check if the puzzle is solved
 * @param state - The game state
 * @returns True if all letters have been revealed
 */
export function isSolved(state: GameState): boolean {
  const board = getCurrentBoard(state);
  return !board.includes('_');
}

/**
 * Process a letter guess
 * @param state - The current game state
 * @param letter - The letter being guessed
 * @returns The updated game state
 */
export function guessLetter(state: GameState, letter: string): GameState {
  const upperLetter = letter.toUpperCase();
  const newGuessedLetters = new Set(state.guessedLetters);
  newGuessedLetters.add(upperLetter);

  const newState = {
    ...state,
    guessedLetters: newGuessedLetters,
  };

  if (isSolved(newState)) {
    newState.solved = true;
  }

  return newState;
}

/**
 * Process a phrase guess
 * @param state - The current game state
 * @param guess - The phrase being guessed
 * @returns The updated game state with solved/failed status
 */
export function guessPhrase(state: GameState, guess: string): GameState {
  const isCorrect = guess.toUpperCase() === state.puzzle.phrase.toUpperCase();

  return {
    ...state,
    solved: isCorrect,
    failed: !isCorrect,
  };
}
